"use strict";
exports.id = 20;
exports.ids = [20];
exports.modules = {

/***/ 97189:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "_": () => (/* binding */ getLatestsSemVersionedTag)
});

;// CONCATENATED MODULE: ./dist/bin/tools/octokit-addons/listTags.js
var __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
const per_page = 99;
function listTagsFactory(params) {
    const { octokit } = params;
    const octokit_repo_listTags = async (params) => {
        return octokit.repos.listTags(params);
    };
    function listTags(params) {
        return __asyncGenerator(this, arguments, function* listTags_1() {
            const { owner, repo } = params;
            let page = 1;
            while (true) {
                const resp = yield __await(octokit_repo_listTags({
                    owner,
                    repo,
                    per_page,
                    page: page++
                }));
                for (const branch of resp.data.map(({ name }) => name)) {
                    yield yield __await(branch);
                }
                if (resp.data.length < 99) {
                    break;
                }
            }
        });
    }
    /** Returns the same "latest" tag as deno.land/x, not actually the latest though */
    async function getLatestTag(params) {
        const { owner, repo } = params;
        const itRes = await listTags({ owner, repo }).next();
        if (itRes.done) {
            return undefined;
        }
        return itRes.value;
    }
    return { listTags, getLatestTag };
}
//# sourceMappingURL=listTags.js.map
// EXTERNAL MODULE: ./dist/bin/tools/SemVer.js
var SemVer = __webpack_require__(12171);
;// CONCATENATED MODULE: ./dist/bin/tools/octokit-addons/getLatestsSemVersionedTag.js
var __asyncValues = (undefined && undefined.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};


function getLatestsSemVersionedTagFactory(params) {
    const { octokit } = params;
    async function getLatestsSemVersionedTag(params) {
        var _a, e_1, _b, _c;
        const { owner, repo, count, doIgnoreReleaseCandidates } = params;
        const semVersionedTags = [];
        const { listTags } = listTagsFactory({ octokit });
        try {
            for (var _d = true, _e = __asyncValues(listTags({ owner, repo })), _f; _f = await _e.next(), _a = _f.done, !_a;) {
                _c = _f.value;
                _d = false;
                try {
                    const tag = _c;
                    let version;
                    try {
                        version = SemVer/* SemVer.parse */.h.parse(tag.replace(/^[vV]?/, ""));
                    }
                    catch (_g) {
                        continue;
                    }
                    if (doIgnoreReleaseCandidates && version.rc !== undefined) {
                        continue;
                    }
                    semVersionedTags.push({ tag, version });
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return semVersionedTags
            .sort(({ version: vX }, { version: vY }) => SemVer/* SemVer.compare */.h.compare(vY, vX))
            .slice(0, count);
    }
    return { getLatestsSemVersionedTag };
}
//# sourceMappingURL=getLatestsSemVersionedTag.js.map
// EXTERNAL MODULE: ./node_modules/@octokit/rest/dist-node/index.js
var dist_node = __webpack_require__(55375);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(71017);
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(57147);
// EXTERNAL MODULE: ./node_modules/zod/lib/index.mjs
var lib = __webpack_require__(52300);
// EXTERNAL MODULE: ./node_modules/tsafe/esm/assert.mjs + 1 modules
var assert = __webpack_require__(29041);
// EXTERNAL MODULE: ./node_modules/tsafe/esm/id.mjs
var id = __webpack_require__(38469);
// EXTERNAL MODULE: ./node_modules/evt/tools/inDepth/same.js
var same = __webpack_require__(33805);
// EXTERNAL MODULE: ./node_modules/make-fetch-happen/lib/index.js
var make_fetch_happen_lib = __webpack_require__(9525);
var lib_default = /*#__PURE__*/__webpack_require__.n(make_fetch_happen_lib);
;// CONCATENATED MODULE: ./dist/bin/shared/getLatestsSemVersionedTag.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









let getLatestsSemVersionedTag_stateless = undefined;
const CACHE_VERSION = 1;
(0,assert/* assert */.h)();
async function getLatestsSemVersionedTag(_a) {
    var { buildContext } = _a, params = __rest(_a, ["buildContext"]);
    const cacheFilePath = (0,external_path_.join)(buildContext.cacheDirPath, "latest-sem-versioned-tags.json");
    const cacheLookupResult = (() => {
        const getResult_currentCache = (currentCacheEntries) => ({
            hasCachedResult: false,
            currentCache: {
                version: CACHE_VERSION,
                entries: currentCacheEntries
            }
        });
        if (!external_fs_.existsSync(cacheFilePath)) {
            return getResult_currentCache([]);
        }
        let cache_json;
        try {
            cache_json = external_fs_.readFileSync(cacheFilePath).toString("utf8");
        }
        catch (_a) {
            return getResult_currentCache([]);
        }
        let cache_json_parsed;
        try {
            cache_json_parsed = JSON.parse(cache_json);
        }
        catch (_b) {
            return getResult_currentCache([]);
        }
        const zSemVer = (() => {
            const zTargetType = lib.z.object({
                major: lib.z.number(),
                minor: lib.z.number(),
                patch: lib.z.number(),
                rc: lib.z.number().optional(),
                parsedFrom: lib.z.string()
            });
            (0,assert/* assert */.h)();
            return (0,id.id)(zTargetType);
        })();
        const zCache = (() => {
            const zTargetType = lib.z.object({
                version: lib.z.literal(CACHE_VERSION),
                entries: lib.z.array(lib.z.object({
                    time: lib.z.number(),
                    params: lib.z.object({
                        owner: lib.z.string(),
                        repo: lib.z.string(),
                        count: lib.z.number(),
                        doIgnoreReleaseCandidates: lib.z.boolean()
                    }),
                    result: lib.z.array(lib.z.object({
                        tag: lib.z.string(),
                        version: zSemVer
                    }))
                }))
            });
            (0,assert/* assert */.h)();
            return (0,id.id)(zTargetType);
        })();
        let cache;
        try {
            cache = zCache.parse(cache_json_parsed);
        }
        catch (_c) {
            return getResult_currentCache([]);
        }
        const cacheEntry = cache.entries.find(e => (0,same.same)(e.params, params));
        if (cacheEntry === undefined) {
            return getResult_currentCache(cache.entries);
        }
        if (Date.now() - cacheEntry.time > 3600000) {
            return getResult_currentCache(cache.entries.filter(e => e !== cacheEntry));
        }
        return {
            hasCachedResult: true,
            cachedResult: cacheEntry.result
        };
    })();
    if (cacheLookupResult.hasCachedResult) {
        return cacheLookupResult.cachedResult;
    }
    const { currentCache } = cacheLookupResult;
    getLatestsSemVersionedTag_stateless !== null && getLatestsSemVersionedTag_stateless !== void 0 ? getLatestsSemVersionedTag_stateless : (getLatestsSemVersionedTag_stateless = (() => {
        const octokit = (() => {
            const githubToken = process.env.GITHUB_TOKEN;
            const octokit = new dist_node.Octokit(Object.assign(Object.assign({}, (githubToken === undefined ? {} : { auth: githubToken })), { request: {
                    fetch: (url, options) => lib_default()(url, Object.assign(Object.assign({}, options), buildContext.fetchOptions))
                } }));
            return octokit;
        })();
        const { getLatestsSemVersionedTag } = getLatestsSemVersionedTagFactory({
            octokit
        });
        return getLatestsSemVersionedTag;
    })());
    const result = await getLatestsSemVersionedTag_stateless(params);
    currentCache.entries.push({
        time: Date.now(),
        params,
        result
    });
    {
        const dirPath = (0,external_path_.dirname)(cacheFilePath);
        if (!external_fs_.existsSync(dirPath)) {
            external_fs_.mkdirSync(dirPath, { recursive: true });
        }
    }
    external_fs_.writeFileSync(cacheFilePath, JSON.stringify(currentCache, null, 2));
    return result;
}
//# sourceMappingURL=getLatestsSemVersionedTag.js.map

/***/ }),

/***/ 82635:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "s": () => (/* binding */ promptKeycloakVersion)
/* harmony export */ });
/* harmony import */ var _getLatestsSemVersionedTag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97189);
/* harmony import */ var cli_select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99398);
/* harmony import */ var cli_select__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(cli_select__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var tsafe_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29041);
/* harmony import */ var _tools_SemVer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12171);




(0,tsafe_assert__WEBPACK_IMPORTED_MODULE_2__/* .assert */ .h)();
async function promptKeycloakVersion(params) {
    const { startingFromMajor, excludeMajorVersions, doOmitPatch, buildContext } = params;
    const semVersionedTagByMajor = new Map();
    const semVersionedTags = await (0,_getLatestsSemVersionedTag__WEBPACK_IMPORTED_MODULE_0__/* .getLatestsSemVersionedTag */ ._)({
        count: 50,
        owner: "keycloak",
        repo: "keycloak",
        doIgnoreReleaseCandidates: true,
        buildContext
    });
    semVersionedTags.forEach(semVersionedTag => {
        if (startingFromMajor !== undefined &&
            semVersionedTag.version.major < startingFromMajor) {
            return;
        }
        if (excludeMajorVersions.includes(semVersionedTag.version.major)) {
            return;
        }
        const currentSemVersionedTag = semVersionedTagByMajor.get(semVersionedTag.version.major);
        if (currentSemVersionedTag !== undefined &&
            _tools_SemVer__WEBPACK_IMPORTED_MODULE_3__/* .SemVer.compare */ .h.compare(semVersionedTag.version, currentSemVersionedTag.version) === -1) {
            return;
        }
        semVersionedTagByMajor.set(semVersionedTag.version.major, semVersionedTag);
    });
    const lastMajorVersions = Array.from(semVersionedTagByMajor.values()).map(({ version }) => `${version.major}.${version.minor}${doOmitPatch ? "" : `.${version.patch}`}`);
    const { value } = await cli_select__WEBPACK_IMPORTED_MODULE_1___default()({
        values: lastMajorVersions
    }).catch(() => {
        process.exit(-1);
    });
    const keycloakVersion = value.split(" ")[0];
    return { keycloakVersion };
}
//# sourceMappingURL=promptKeycloakVersion.js.map

/***/ }),

/***/ 12171:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ SemVer)
/* harmony export */ });
var SemVer;
(function (SemVer) {
    const bumpTypes = ["major", "minor", "patch", "rc", "no bump"];
    function parse(versionStr) {
        const match = versionStr.match(/^v?([0-9]+)\.([0-9]+)(?:\.([0-9]+))?(?:-rc.([0-9]+))?$/);
        if (!match) {
            throw new Error(`${versionStr} is not a valid semantic version`);
        }
        const semVer = Object.assign({ major: parseInt(match[1]), minor: parseInt(match[2]), patch: (() => {
                const str = match[3];
                return str === undefined ? 0 : parseInt(str);
            })() }, (() => {
            const str = match[4];
            return str === undefined ? {} : { rc: parseInt(str) };
        })());
        const initialStr = stringify(semVer);
        Object.defineProperty(semVer, "parsedFrom", {
            enumerable: true,
            get: function () {
                const currentStr = stringify(this);
                if (currentStr !== initialStr) {
                    throw new Error(`SemVer.parsedFrom can't be read anymore, the version have been modified from ${initialStr} to ${currentStr}`);
                }
                return versionStr;
            }
        });
        return semVer;
    }
    SemVer.parse = parse;
    function stringify(v) {
        return `${v.major}.${v.minor}.${v.patch}${v.rc === undefined ? "" : `-rc.${v.rc}`}`;
    }
    SemVer.stringify = stringify;
    /**
     *
     * v1  <  v2  => -1
     * v1 === v2  => 0
     * v1  >  v2  => 1
     *
     */
    function compare(v1, v2) {
        const sign = (diff) => (diff === 0 ? 0 : diff < 0 ? -1 : 1);
        const noUndefined = (n) => n !== null && n !== void 0 ? n : Infinity;
        for (const level of ["major", "minor", "patch", "rc"]) {
            if (noUndefined(v1[level]) !== noUndefined(v2[level])) {
                return sign(noUndefined(v1[level]) - noUndefined(v2[level]));
            }
        }
        return 0;
    }
    SemVer.compare = compare;
    /*
    console.log(compare(parse("3.0.0-rc.3"), parse("3.0.0")) === -1 )
    console.log(compare(parse("3.0.0-rc.3"), parse("3.0.0-rc.4")) === -1 )
    console.log(compare(parse("3.0.0-rc.3"), parse("4.0.0")) === -1 )
    */
    function bumpType(params) {
        const versionAhead = typeof params.versionAhead === "string"
            ? parse(params.versionAhead)
            : params.versionAhead;
        const versionBehind = typeof params.versionBehind === "string"
            ? parse(params.versionBehind)
            : params.versionBehind;
        if (compare(versionBehind, versionAhead) === 1) {
            throw new Error(`Version regression ${stringify(versionBehind)} -> ${stringify(versionAhead)}`);
        }
        for (const level of ["major", "minor", "patch", "rc"]) {
            if (versionBehind[level] !== versionAhead[level]) {
                return level;
            }
        }
        return "no bump";
    }
    SemVer.bumpType = bumpType;
})(SemVer || (SemVer = {}));
//# sourceMappingURL=SemVer.js.map

/***/ }),

/***/ 38367:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "I": () => (/* binding */ downloadAndExtractArchive)
/* harmony export */ });
/* harmony import */ var make_fetch_happen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9525);
/* harmony import */ var make_fetch_happen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(make_fetch_happen__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73292);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var tsafe_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29041);
/* harmony import */ var _extractArchive__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29121);
/* harmony import */ var _fs_existsAsync__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43765);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _fs_rm__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8699);








async function downloadAndExtractArchive(params) {
    var _a;
    const { url, uniqueIdOfOnArchiveFile, onArchiveFile, cacheDirPath, fetchOptions } = params;
    const archiveFileBasename = url.split("?")[0].split("/").reverse()[0];
    const archiveFilePath = (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(cacheDirPath, archiveFileBasename);
    download: {
        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_1__.mkdir)((0,path__WEBPACK_IMPORTED_MODULE_2__.dirname)(archiveFilePath), { recursive: true });
        if (await (0,_fs_existsAsync__WEBPACK_IMPORTED_MODULE_5__/* .existsAsync */ .o)(archiveFilePath)) {
            const isDownloaded = await SuccessTracker.getIsDownloaded({
                cacheDirPath,
                archiveFileBasename
            });
            if (isDownloaded) {
                break download;
            }
            await (0,fs_promises__WEBPACK_IMPORTED_MODULE_1__.unlink)(archiveFilePath);
            await SuccessTracker.removeFromDownloaded({
                cacheDirPath,
                archiveFileBasename
            });
        }
        const response = await make_fetch_happen__WEBPACK_IMPORTED_MODULE_0___default()(url, fetchOptions);
        (_a = response.body) === null || _a === void 0 ? void 0 : _a.setMaxListeners(Number.MAX_VALUE);
        (0,tsafe_assert__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(typeof response.body !== "undefined" && response.body != null);
        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_1__.writeFile)(archiveFilePath, response.body);
        await SuccessTracker.markAsDownloaded({
            cacheDirPath,
            archiveFileBasename
        });
    }
    const extractDirBasename = `${archiveFileBasename.replace(/\.([^.]+)$/, (...[, ext]) => `_${ext}`)}_${uniqueIdOfOnArchiveFile}_${crypto__WEBPACK_IMPORTED_MODULE_6__.createHash("sha256")
        .update(onArchiveFile.toString())
        .digest("hex")
        .substring(0, 5)}`;
    await Promise.all((await (0,fs_promises__WEBPACK_IMPORTED_MODULE_1__.readdir)(cacheDirPath))
        .filter((() => {
        const prefix = extractDirBasename
            .split("_")
            .reverse()
            .slice(1)
            .reverse()
            .join("_");
        return basename => basename !== extractDirBasename && basename.startsWith(prefix);
    })())
        .map(async (extractDirBasename) => {
        await (0,_fs_rm__WEBPACK_IMPORTED_MODULE_7__.rm)((0,path__WEBPACK_IMPORTED_MODULE_2__.join)(cacheDirPath, extractDirBasename), {
            recursive: true
        });
        await SuccessTracker.removeFromExtracted({
            cacheDirPath,
            extractDirBasename
        });
    }));
    const extractedDirPath = (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(cacheDirPath, extractDirBasename);
    extract_and_transform: {
        if (await (0,_fs_existsAsync__WEBPACK_IMPORTED_MODULE_5__/* .existsAsync */ .o)(extractedDirPath)) {
            const isExtracted = await SuccessTracker.getIsExtracted({
                cacheDirPath,
                extractDirBasename
            });
            if (isExtracted) {
                break extract_and_transform;
            }
            await (0,_fs_rm__WEBPACK_IMPORTED_MODULE_7__.rm)(extractedDirPath, { recursive: true });
            await SuccessTracker.removeFromExtracted({
                cacheDirPath,
                extractDirBasename
            });
        }
        await (0,_extractArchive__WEBPACK_IMPORTED_MODULE_4__/* .extractArchive */ .N)({
            archiveFilePath,
            onArchiveFile: async ({ relativeFilePathInArchive, readFile, writeFile }) => onArchiveFile({
                fileRelativePath: relativeFilePathInArchive,
                readFile,
                writeFile: ({ fileRelativePath, modifiedData }) => writeFile({
                    filePath: (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(extractedDirPath, fileRelativePath),
                    modifiedData
                })
            })
        });
        await SuccessTracker.markAsExtracted({
            cacheDirPath,
            extractDirBasename
        });
    }
    return { extractedDirPath, archiveFilePath };
}
var SuccessTracker;
(function (SuccessTracker) {
    async function read(params) {
        const { cacheDirPath } = params;
        const filePath = (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(cacheDirPath, "downloadAndExtractArchive.json");
        if (!(await (0,_fs_existsAsync__WEBPACK_IMPORTED_MODULE_5__/* .existsAsync */ .o)(filePath))) {
            return { archiveFileBasenames: [], extractDirBasenames: [] };
        }
        return JSON.parse((await (0,fs_promises__WEBPACK_IMPORTED_MODULE_1__.readFile)(filePath)).toString("utf8"));
    }
    async function write(params) {
        const { cacheDirPath, successTracker } = params;
        const filePath = (0,path__WEBPACK_IMPORTED_MODULE_2__.join)(cacheDirPath, "downloadAndExtractArchive.json");
        {
            const dirPath = (0,path__WEBPACK_IMPORTED_MODULE_2__.dirname)(filePath);
            if (!(await (0,_fs_existsAsync__WEBPACK_IMPORTED_MODULE_5__/* .existsAsync */ .o)(dirPath))) {
                await (0,fs_promises__WEBPACK_IMPORTED_MODULE_1__.mkdir)(dirPath, { recursive: true });
            }
        }
        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_1__.writeFile)(filePath, JSON.stringify(successTracker));
    }
    async function markAsDownloaded(params) {
        const { cacheDirPath, archiveFileBasename } = params;
        const successTracker = await read({ cacheDirPath });
        successTracker.archiveFileBasenames.push(archiveFileBasename);
        await write({ cacheDirPath, successTracker });
    }
    SuccessTracker.markAsDownloaded = markAsDownloaded;
    async function getIsDownloaded(params) {
        const { cacheDirPath, archiveFileBasename } = params;
        const successTracker = await read({ cacheDirPath });
        return successTracker.archiveFileBasenames.includes(archiveFileBasename);
    }
    SuccessTracker.getIsDownloaded = getIsDownloaded;
    async function removeFromDownloaded(params) {
        const { cacheDirPath, archiveFileBasename } = params;
        const successTracker = await read({ cacheDirPath });
        successTracker.archiveFileBasenames = successTracker.archiveFileBasenames.filter(basename => basename !== archiveFileBasename);
        await write({ cacheDirPath, successTracker });
    }
    SuccessTracker.removeFromDownloaded = removeFromDownloaded;
    async function markAsExtracted(params) {
        const { cacheDirPath, extractDirBasename } = params;
        const successTracker = await read({ cacheDirPath });
        successTracker.extractDirBasenames.push(extractDirBasename);
        await write({ cacheDirPath, successTracker });
    }
    SuccessTracker.markAsExtracted = markAsExtracted;
    async function getIsExtracted(params) {
        const { cacheDirPath, extractDirBasename } = params;
        const successTracker = await read({ cacheDirPath });
        return successTracker.extractDirBasenames.includes(extractDirBasename);
    }
    SuccessTracker.getIsExtracted = getIsExtracted;
    async function removeFromExtracted(params) {
        const { cacheDirPath, extractDirBasename } = params;
        const successTracker = await read({ cacheDirPath });
        successTracker.extractDirBasenames = successTracker.extractDirBasenames.filter(basename => basename !== extractDirBasename);
        await write({ cacheDirPath, successTracker });
    }
    SuccessTracker.removeFromExtracted = removeFromExtracted;
})(SuccessTracker || (SuccessTracker = {}));
//# sourceMappingURL=downloadAndExtractArchive.js.map

/***/ }),

/***/ 29121:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": () => (/* binding */ extractArchive)
/* harmony export */ });
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73292);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57147);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var yauzl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78781);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12781);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var evt_tools_Deferred__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50689);
/* harmony import */ var evt_tools_Deferred__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(evt_tools_Deferred__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _fs_existsAsync__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(43765);







async function extractArchive(params) {
    const { archiveFilePath, onArchiveFile } = params;
    const zipFile = await new Promise((resolve, reject) => {
        yauzl__WEBPACK_IMPORTED_MODULE_2__.open(archiveFilePath, { lazyEntries: true }, async (error, zipFile) => {
            if (error) {
                reject(error);
                return;
            }
            resolve(zipFile);
        });
    });
    const dDone = new evt_tools_Deferred__WEBPACK_IMPORTED_MODULE_4__.Deferred();
    zipFile.once("end", () => {
        zipFile.close();
        dDone.resolve();
    });
    const writeFile = async (entry, params) => {
        const { filePath, modifiedData } = params;
        {
            const dirPath = (0,path__WEBPACK_IMPORTED_MODULE_5__.dirname)(filePath);
            if (!(await (0,_fs_existsAsync__WEBPACK_IMPORTED_MODULE_6__/* .existsAsync */ .o)(dirPath))) {
                await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().mkdir(dirPath, { recursive: true });
            }
        }
        if (modifiedData !== undefined) {
            await fs_promises__WEBPACK_IMPORTED_MODULE_0___default().writeFile(filePath, modifiedData);
            return;
        }
        const readStream = await new Promise(resolve => zipFile.openReadStream(entry, async (error, readStream) => {
            if (error) {
                dDone.reject(error);
                return;
            }
            resolve(readStream);
        }));
        const dDoneWithFile = new evt_tools_Deferred__WEBPACK_IMPORTED_MODULE_4__.Deferred();
        stream__WEBPACK_IMPORTED_MODULE_3___default().pipeline(readStream, fs__WEBPACK_IMPORTED_MODULE_1___default().createWriteStream(filePath), error => {
            if (error) {
                dDone.reject(error);
                return;
            }
            dDoneWithFile.resolve();
        });
        await dDoneWithFile.pr;
    };
    const readFile = (entry) => new Promise(resolve => zipFile.openReadStream(entry, async (error, readStream) => {
        if (error) {
            dDone.reject(error);
            return;
        }
        const chunks = [];
        readStream.on("data", chunk => {
            chunks.push(chunk);
        });
        readStream.on("end", () => {
            resolve(Buffer.concat(chunks));
        });
        readStream.on("error", error => {
            dDone.reject(error);
        });
    }));
    zipFile.on("entry", async (entry) => {
        handle_file: {
            // NOTE: Skip directories
            if (entry.fileName.endsWith("/")) {
                break handle_file;
            }
            let hasEarlyExitBeenCalled = false;
            await onArchiveFile({
                relativeFilePathInArchive: entry.fileName.split("/").join(path__WEBPACK_IMPORTED_MODULE_5__.sep),
                readFile: () => readFile(entry),
                writeFile: params => writeFile(entry, params),
                earlyExit: () => {
                    hasEarlyExitBeenCalled = true;
                }
            });
            if (hasEarlyExitBeenCalled) {
                zipFile.close();
                dDone.resolve();
                return;
            }
        }
        zipFile.readEntry();
    });
    zipFile.readEntry();
    await dDone.pr;
}
//# sourceMappingURL=extractArchive.js.map

/***/ }),

/***/ 43765:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "o": () => (/* binding */ existsAsync)
/* harmony export */ });
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73292);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_0__);

async function existsAsync(path) {
    try {
        await fs_promises__WEBPACK_IMPORTED_MODULE_0__.stat(path);
        return true;
    }
    catch (error) {
        if (error.code === "ENOENT")
            return false;
        throw error;
    }
}
//# sourceMappingURL=fs.existsAsync.js.map

/***/ }),

/***/ 8699:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rm": () => (/* binding */ rm)
/* harmony export */ });
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73292);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _SemVer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12171);



/**
 * Polyfill of fs.rm(dirPath, { "recursive": true })
 * For older version of Node
 */
async function rm(dirPath, options) {
    if (_SemVer__WEBPACK_IMPORTED_MODULE_2__/* .SemVer.compare */ .h.compare(_SemVer__WEBPACK_IMPORTED_MODULE_2__/* .SemVer.parse */ .h.parse(process.version), _SemVer__WEBPACK_IMPORTED_MODULE_2__/* .SemVer.parse */ .h.parse("14.14.0")) > 0) {
        return fs_promises__WEBPACK_IMPORTED_MODULE_0__.rm(dirPath, options);
    }
    const { force = true } = options;
    if (force && !(await checkDirExists(dirPath))) {
        return;
    }
    const removeDir_rec = async (dirPath) => Promise.all((await fs_promises__WEBPACK_IMPORTED_MODULE_0__.readdir(dirPath)).map(async (basename) => {
        const fileOrDirpath = (0,path__WEBPACK_IMPORTED_MODULE_1__.join)(dirPath, basename);
        if ((await fs_promises__WEBPACK_IMPORTED_MODULE_0__.lstat(fileOrDirpath)).isDirectory()) {
            await removeDir_rec(fileOrDirpath);
        }
        else {
            await fs_promises__WEBPACK_IMPORTED_MODULE_0__.unlink(fileOrDirpath);
        }
    }));
    await removeDir_rec(dirPath);
}
async function checkDirExists(dirPath) {
    try {
        await fs_promises__WEBPACK_IMPORTED_MODULE_0__.access(dirPath, fs_promises__WEBPACK_IMPORTED_MODULE_0__.constants.F_OK);
        return true;
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=fs.rm.js.map

/***/ })

};
;