"use strict";
exports.id = 599;
exports.ids = [599];
exports.modules = {

/***/ 81434:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": () => (/* binding */ copyBoilerplate)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57147);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71017);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _tools_getThisCodebaseRootDirPath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58822);
/* harmony import */ var tsafe_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29041);




function copyBoilerplate(params) {
    const { accountThemeType, accountThemeSrcDirPath } = params;
    fs__WEBPACK_IMPORTED_MODULE_0__.cpSync((0,path__WEBPACK_IMPORTED_MODULE_1__.join)((0,_tools_getThisCodebaseRootDirPath__WEBPACK_IMPORTED_MODULE_2__/* .getThisCodebaseRootDirPath */ .e)(), "src", "bin", "initialize-account-theme", "src", (() => {
        switch (accountThemeType) {
            case "Single-Page":
                return "single-page";
            case "Multi-Page":
                return "multi-page";
        }
        (0,tsafe_assert__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(false);
    })()), accountThemeSrcDirPath, { recursive: true });
}
//# sourceMappingURL=copyBoilerplate.js.map

/***/ }),

/***/ 97599:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "initializeAccountTheme_singlePage": () => (/* binding */ initializeAccountTheme_singlePage)
});

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(71017);
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(57147);
// EXTERNAL MODULE: ./node_modules/chalk/source/index.js
var source = __webpack_require__(78818);
var source_default = /*#__PURE__*/__webpack_require__.n(source);
// EXTERNAL MODULE: ./dist/bin/shared/getLatestsSemVersionedTag.js + 2 modules
var getLatestsSemVersionedTag = __webpack_require__(97189);
// EXTERNAL MODULE: ./dist/bin/tools/SemVer.js
var SemVer = __webpack_require__(12171);
// EXTERNAL MODULE: ./node_modules/make-fetch-happen/lib/index.js
var lib = __webpack_require__(9525);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);
// EXTERNAL MODULE: ./node_modules/zod/lib/index.mjs
var zod_lib = __webpack_require__(52300);
// EXTERNAL MODULE: ./node_modules/tsafe/esm/assert.mjs + 1 modules
var assert = __webpack_require__(29041);
// EXTERNAL MODULE: ./node_modules/tsafe/esm/is.mjs
var is = __webpack_require__(16453);
// EXTERNAL MODULE: ./node_modules/tsafe/esm/id.mjs
var id = __webpack_require__(38469);
// EXTERNAL MODULE: external "child_process"
var external_child_process_ = __webpack_require__(32081);
;// CONCATENATED MODULE: ./dist/bin/tools/npmInstall.js




function npmInstall(params) {
    const { packageJsonDirPath } = params;
    const packageManagerBinName = (() => {
        const packageMangers = [
            {
                binName: "yarn",
                lockFileBasename: "yarn.lock"
            },
            {
                binName: "npm",
                lockFileBasename: "package-lock.json"
            },
            {
                binName: "pnpm",
                lockFileBasename: "pnpm-lock.yaml"
            },
            {
                binName: "bun",
                lockFileBasename: "bun.lockdb"
            }
        ];
        for (const packageManager of packageMangers) {
            if (external_fs_.existsSync((0,external_path_.join)(packageJsonDirPath, packageManager.lockFileBasename)) ||
                external_fs_.existsSync((0,external_path_.join)(process.cwd(), packageManager.lockFileBasename))) {
                return packageManager.binName;
            }
        }
        return undefined;
    })();
    install_dependencies: {
        if (packageManagerBinName === undefined) {
            break install_dependencies;
        }
        console.log(`Installing the new dependencies...`);
        try {
            external_child_process_.execSync(`${packageManagerBinName} install`, {
                cwd: packageJsonDirPath,
                stdio: "inherit"
            });
        }
        catch (_a) {
            console.log(source_default().yellow(`\`${packageManagerBinName} install\` failed, continuing anyway...`));
        }
    }
}
//# sourceMappingURL=npmInstall.js.map
// EXTERNAL MODULE: ./dist/bin/initialize-account-theme/copyBoilerplate.js
var copyBoilerplate = __webpack_require__(81434);
// EXTERNAL MODULE: ./dist/bin/tools/getThisCodebaseRootDirPath.js
var getThisCodebaseRootDirPath = __webpack_require__(58822);
;// CONCATENATED MODULE: ./dist/bin/initialize-account-theme/initializeAccountTheme_singlePage.js













(0,assert/* assert */.h)();
async function initializeAccountTheme_singlePage(params) {
    const { accountThemeSrcDirPath, buildContext } = params;
    const OWNER = "keycloakify";
    const REPO = "keycloak-account-ui";
    const [semVersionedTag] = await (0,getLatestsSemVersionedTag/* getLatestsSemVersionedTag */._)({
        owner: OWNER,
        repo: REPO,
        count: 1,
        doIgnoreReleaseCandidates: false,
        buildContext
    });
    const dependencies = await lib_default()(`https://raw.githubusercontent.com/${OWNER}/${REPO}/${semVersionedTag.tag}/dependencies.gen.json`, buildContext.fetchOptions)
        .then(r => r.json())
        .then((() => {
        const zDependencies = (() => {
            const zTargetType = zod_lib.z.object({
                dependencies: zod_lib.z.record(zod_lib.z.string()),
                devDependencies: zod_lib.z.record(zod_lib.z.string()).optional()
            });
            (0,assert/* assert */.h)();
            return (0,id.id)(zTargetType);
        })();
        return o => zDependencies.parse(o);
    })());
    dependencies.dependencies["@keycloakify/keycloak-account-ui"] = SemVer/* SemVer.stringify */.h.stringify(semVersionedTag.version);
    const parsedPackageJson = (() => {
        const zParsedPackageJson = (() => {
            const zTargetType = zod_lib.z.object({
                dependencies: zod_lib.z.record(zod_lib.z.string()).optional(),
                devDependencies: zod_lib.z.record(zod_lib.z.string()).optional()
            });
            (0,assert/* assert */.h)();
            return (0,id.id)(zTargetType);
        })();
        const parsedPackageJson = JSON.parse(external_fs_.readFileSync(buildContext.packageJsonFilePath).toString("utf8"));
        zParsedPackageJson.parse(parsedPackageJson);
        (0,assert/* assert */.h)((0,is.is)(parsedPackageJson));
        return parsedPackageJson;
    })();
    parsedPackageJson.dependencies = Object.assign(Object.assign({}, parsedPackageJson.dependencies), dependencies.dependencies);
    parsedPackageJson.devDependencies = Object.assign(Object.assign({}, parsedPackageJson.devDependencies), dependencies.devDependencies);
    if (Object.keys(parsedPackageJson.devDependencies).length === 0) {
        delete parsedPackageJson.devDependencies;
    }
    external_fs_.writeFileSync(buildContext.packageJsonFilePath, JSON.stringify(parsedPackageJson, undefined, 4));
    run_npm_install: {
        if (JSON.parse(external_fs_.readFileSync((0,external_path_.join)((0,getThisCodebaseRootDirPath/* getThisCodebaseRootDirPath */.e)(), "package.json"))
            .toString("utf8"))["version"] === "0.0.0") {
            //NOTE: Linked version
            break run_npm_install;
        }
        npmInstall({ packageJsonDirPath: (0,external_path_.dirname)(buildContext.packageJsonFilePath) });
    }
    (0,copyBoilerplate/* copyBoilerplate */.T)({
        accountThemeType: "Single-Page",
        accountThemeSrcDirPath
    });
    console.log([
        source_default().green("The Single-Page account theme has been successfully initialized."),
        `Using Account UI of Keycloak version: ${source_default().bold(semVersionedTag.tag.split("-")[0])}`,
        `Directory created: ${source_default().bold((0,external_path_.relative)(process.cwd(), accountThemeSrcDirPath))}`,
        `Dependencies added to your project's package.json: `,
        source_default().bold(JSON.stringify(dependencies, null, 2))
    ].join("\n"));
}
//# sourceMappingURL=initializeAccountTheme_singlePage.js.map

/***/ }),

/***/ 97189:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "_": () => (/* binding */ getLatestsSemVersionedTag)
});

;// CONCATENATED MODULE: ./dist/bin/tools/octokit-addons/listTags.js
var __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
const per_page = 99;
function listTagsFactory(params) {
    const { octokit } = params;
    const octokit_repo_listTags = async (params) => {
        return octokit.repos.listTags(params);
    };
    function listTags(params) {
        return __asyncGenerator(this, arguments, function* listTags_1() {
            const { owner, repo } = params;
            let page = 1;
            while (true) {
                const resp = yield __await(octokit_repo_listTags({
                    owner,
                    repo,
                    per_page,
                    page: page++
                }));
                for (const branch of resp.data.map(({ name }) => name)) {
                    yield yield __await(branch);
                }
                if (resp.data.length < 99) {
                    break;
                }
            }
        });
    }
    /** Returns the same "latest" tag as deno.land/x, not actually the latest though */
    async function getLatestTag(params) {
        const { owner, repo } = params;
        const itRes = await listTags({ owner, repo }).next();
        if (itRes.done) {
            return undefined;
        }
        return itRes.value;
    }
    return { listTags, getLatestTag };
}
//# sourceMappingURL=listTags.js.map
// EXTERNAL MODULE: ./dist/bin/tools/SemVer.js
var SemVer = __webpack_require__(12171);
;// CONCATENATED MODULE: ./dist/bin/tools/octokit-addons/getLatestsSemVersionedTag.js
var __asyncValues = (undefined && undefined.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};


function getLatestsSemVersionedTagFactory(params) {
    const { octokit } = params;
    async function getLatestsSemVersionedTag(params) {
        var _a, e_1, _b, _c;
        const { owner, repo, count, doIgnoreReleaseCandidates } = params;
        const semVersionedTags = [];
        const { listTags } = listTagsFactory({ octokit });
        try {
            for (var _d = true, _e = __asyncValues(listTags({ owner, repo })), _f; _f = await _e.next(), _a = _f.done, !_a;) {
                _c = _f.value;
                _d = false;
                try {
                    const tag = _c;
                    let version;
                    try {
                        version = SemVer/* SemVer.parse */.h.parse(tag.replace(/^[vV]?/, ""));
                    }
                    catch (_g) {
                        continue;
                    }
                    if (doIgnoreReleaseCandidates && version.rc !== undefined) {
                        continue;
                    }
                    semVersionedTags.push({ tag, version });
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return semVersionedTags
            .sort(({ version: vX }, { version: vY }) => SemVer/* SemVer.compare */.h.compare(vY, vX))
            .slice(0, count);
    }
    return { getLatestsSemVersionedTag };
}
//# sourceMappingURL=getLatestsSemVersionedTag.js.map
// EXTERNAL MODULE: ./node_modules/@octokit/rest/dist-node/index.js
var dist_node = __webpack_require__(55375);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(71017);
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(57147);
// EXTERNAL MODULE: ./node_modules/zod/lib/index.mjs
var lib = __webpack_require__(52300);
// EXTERNAL MODULE: ./node_modules/tsafe/esm/assert.mjs + 1 modules
var assert = __webpack_require__(29041);
// EXTERNAL MODULE: ./node_modules/tsafe/esm/id.mjs
var id = __webpack_require__(38469);
// EXTERNAL MODULE: ./node_modules/evt/tools/inDepth/same.js
var same = __webpack_require__(33805);
// EXTERNAL MODULE: ./node_modules/make-fetch-happen/lib/index.js
var make_fetch_happen_lib = __webpack_require__(9525);
var lib_default = /*#__PURE__*/__webpack_require__.n(make_fetch_happen_lib);
;// CONCATENATED MODULE: ./dist/bin/shared/getLatestsSemVersionedTag.js
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









let getLatestsSemVersionedTag_stateless = undefined;
const CACHE_VERSION = 1;
(0,assert/* assert */.h)();
async function getLatestsSemVersionedTag(_a) {
    var { buildContext } = _a, params = __rest(_a, ["buildContext"]);
    const cacheFilePath = (0,external_path_.join)(buildContext.cacheDirPath, "latest-sem-versioned-tags.json");
    const cacheLookupResult = (() => {
        const getResult_currentCache = (currentCacheEntries) => ({
            hasCachedResult: false,
            currentCache: {
                version: CACHE_VERSION,
                entries: currentCacheEntries
            }
        });
        if (!external_fs_.existsSync(cacheFilePath)) {
            return getResult_currentCache([]);
        }
        let cache_json;
        try {
            cache_json = external_fs_.readFileSync(cacheFilePath).toString("utf8");
        }
        catch (_a) {
            return getResult_currentCache([]);
        }
        let cache_json_parsed;
        try {
            cache_json_parsed = JSON.parse(cache_json);
        }
        catch (_b) {
            return getResult_currentCache([]);
        }
        const zSemVer = (() => {
            const zTargetType = lib.z.object({
                major: lib.z.number(),
                minor: lib.z.number(),
                patch: lib.z.number(),
                rc: lib.z.number().optional(),
                parsedFrom: lib.z.string()
            });
            (0,assert/* assert */.h)();
            return (0,id.id)(zTargetType);
        })();
        const zCache = (() => {
            const zTargetType = lib.z.object({
                version: lib.z.literal(CACHE_VERSION),
                entries: lib.z.array(lib.z.object({
                    time: lib.z.number(),
                    params: lib.z.object({
                        owner: lib.z.string(),
                        repo: lib.z.string(),
                        count: lib.z.number(),
                        doIgnoreReleaseCandidates: lib.z.boolean()
                    }),
                    result: lib.z.array(lib.z.object({
                        tag: lib.z.string(),
                        version: zSemVer
                    }))
                }))
            });
            (0,assert/* assert */.h)();
            return (0,id.id)(zTargetType);
        })();
        let cache;
        try {
            cache = zCache.parse(cache_json_parsed);
        }
        catch (_c) {
            return getResult_currentCache([]);
        }
        const cacheEntry = cache.entries.find(e => (0,same.same)(e.params, params));
        if (cacheEntry === undefined) {
            return getResult_currentCache(cache.entries);
        }
        if (Date.now() - cacheEntry.time > 3600000) {
            return getResult_currentCache(cache.entries.filter(e => e !== cacheEntry));
        }
        return {
            hasCachedResult: true,
            cachedResult: cacheEntry.result
        };
    })();
    if (cacheLookupResult.hasCachedResult) {
        return cacheLookupResult.cachedResult;
    }
    const { currentCache } = cacheLookupResult;
    getLatestsSemVersionedTag_stateless !== null && getLatestsSemVersionedTag_stateless !== void 0 ? getLatestsSemVersionedTag_stateless : (getLatestsSemVersionedTag_stateless = (() => {
        const octokit = (() => {
            const githubToken = process.env.GITHUB_TOKEN;
            const octokit = new dist_node.Octokit(Object.assign(Object.assign({}, (githubToken === undefined ? {} : { auth: githubToken })), { request: {
                    fetch: (url, options) => lib_default()(url, Object.assign(Object.assign({}, options), buildContext.fetchOptions))
                } }));
            return octokit;
        })();
        const { getLatestsSemVersionedTag } = getLatestsSemVersionedTagFactory({
            octokit
        });
        return getLatestsSemVersionedTag;
    })());
    const result = await getLatestsSemVersionedTag_stateless(params);
    currentCache.entries.push({
        time: Date.now(),
        params,
        result
    });
    {
        const dirPath = (0,external_path_.dirname)(cacheFilePath);
        if (!external_fs_.existsSync(dirPath)) {
            external_fs_.mkdirSync(dirPath, { recursive: true });
        }
    }
    external_fs_.writeFileSync(cacheFilePath, JSON.stringify(currentCache, null, 2));
    return result;
}
//# sourceMappingURL=getLatestsSemVersionedTag.js.map

/***/ }),

/***/ 12171:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ SemVer)
/* harmony export */ });
var SemVer;
(function (SemVer) {
    const bumpTypes = ["major", "minor", "patch", "rc", "no bump"];
    function parse(versionStr) {
        const match = versionStr.match(/^v?([0-9]+)\.([0-9]+)(?:\.([0-9]+))?(?:-rc.([0-9]+))?$/);
        if (!match) {
            throw new Error(`${versionStr} is not a valid semantic version`);
        }
        const semVer = Object.assign({ major: parseInt(match[1]), minor: parseInt(match[2]), patch: (() => {
                const str = match[3];
                return str === undefined ? 0 : parseInt(str);
            })() }, (() => {
            const str = match[4];
            return str === undefined ? {} : { rc: parseInt(str) };
        })());
        const initialStr = stringify(semVer);
        Object.defineProperty(semVer, "parsedFrom", {
            enumerable: true,
            get: function () {
                const currentStr = stringify(this);
                if (currentStr !== initialStr) {
                    throw new Error(`SemVer.parsedFrom can't be read anymore, the version have been modified from ${initialStr} to ${currentStr}`);
                }
                return versionStr;
            }
        });
        return semVer;
    }
    SemVer.parse = parse;
    function stringify(v) {
        return `${v.major}.${v.minor}.${v.patch}${v.rc === undefined ? "" : `-rc.${v.rc}`}`;
    }
    SemVer.stringify = stringify;
    /**
     *
     * v1  <  v2  => -1
     * v1 === v2  => 0
     * v1  >  v2  => 1
     *
     */
    function compare(v1, v2) {
        const sign = (diff) => (diff === 0 ? 0 : diff < 0 ? -1 : 1);
        const noUndefined = (n) => n !== null && n !== void 0 ? n : Infinity;
        for (const level of ["major", "minor", "patch", "rc"]) {
            if (noUndefined(v1[level]) !== noUndefined(v2[level])) {
                return sign(noUndefined(v1[level]) - noUndefined(v2[level]));
            }
        }
        return 0;
    }
    SemVer.compare = compare;
    /*
    console.log(compare(parse("3.0.0-rc.3"), parse("3.0.0")) === -1 )
    console.log(compare(parse("3.0.0-rc.3"), parse("3.0.0-rc.4")) === -1 )
    console.log(compare(parse("3.0.0-rc.3"), parse("4.0.0")) === -1 )
    */
    function bumpType(params) {
        const versionAhead = typeof params.versionAhead === "string"
            ? parse(params.versionAhead)
            : params.versionAhead;
        const versionBehind = typeof params.versionBehind === "string"
            ? parse(params.versionBehind)
            : params.versionBehind;
        if (compare(versionBehind, versionAhead) === 1) {
            throw new Error(`Version regression ${stringify(versionBehind)} -> ${stringify(versionAhead)}`);
        }
        for (const level of ["major", "minor", "patch", "rc"]) {
            if (versionBehind[level] !== versionAhead[level]) {
                return level;
            }
        }
        return "no bump";
    }
    SemVer.bumpType = bumpType;
})(SemVer || (SemVer = {}));
//# sourceMappingURL=SemVer.js.map

/***/ })

};
;